import { nanoid } from "nanoid";

const makeId = () => (typeof crypto !== "undefined" && crypto.randomUUID ? crypto.randomUUID() : nanoid());

export function blueprintToTemplate(blueprint = {}, metadata = {}) {
  // Prefer universal node-based blueprint
  if (blueprint.nodes && Array.isArray(blueprint.nodes)) {
    return convertUniversalBlueprint(blueprint, metadata);
  }

  // Fallback: legacy sections blueprint
  const frameId = makeId();
  const width = metadata.width || 1440;
  const height = metadata.height || 900;
  const nodes = {};

  const rootFrame = {
    id: frameId,
    type: "frame",
    name: blueprint.name || metadata.name || "AI Template",
    x: 0,
    y: 0,
    width,
    height,
    children: [],
    layout: { enabled: true, direction: "vertical", spacing: 24, padding: { top: 48, right: 48, bottom: 48, left: 48 }, alignment: "start" },
    constraints: { horizontal: "left", vertical: "top" },
  };

  (blueprint.sections || []).forEach((section) => {
    const sectionId = makeId();
    const childIds = [];
    const layout = {
      enabled: true,
      direction: section.layout?.direction || "vertical",
      spacing: section.layout?.gap || 16,
      padding: {
        top: section.layout?.padding || 24,
        right: section.layout?.padding || 24,
        bottom: section.layout?.padding || 24,
        left: section.layout?.padding || 24,
      },
      alignment: section.layout?.alignment || "start",
    };

    (section.components || []).forEach((comp) => {
      const id = makeId();
      const base = {
        id,
        name: comp.role || comp.type,
        children: [],
        parent: sectionId,
        x: 0,
        y: 0,
        width: comp.width || 320,
        height: comp.height || 64,
        constraints: { horizontal: "left", vertical: "top" },
      };
      if (comp.type === "text") {
        nodes[id] = {
          ...base,
          type: "text",
          text: comp.content || comp.props?.text || "Placeholder",
          fontSize: comp.role === "heading" ? 36 : 18,
          fill: "#0f172a",
        };
      } else if (comp.type === "button") {
        nodes[id] = {
          ...base,
          type: "frame",
          width: comp.width || 180,
          height: comp.height || 48,
          background: "#6366f1",
          layout: { enabled: true, direction: "horizontal", spacing: 8, padding: { top: 10, right: 16, bottom: 10, left: 16 }, alignment: "center" },
          children: [],
        };
        const labelId = makeId();
        nodes[labelId] = {
          id: labelId,
          type: "text",
          name: "Button Label",
          text: comp.props?.text || "Get Started",
          fontSize: 16,
          fill: "#ffffff",
          parent: id,
          x: 0,
          y: 0,
          constraints: { horizontal: "center", vertical: "center" },
        };
        nodes[id].children.push(labelId);
      } else if (comp.type === "image") {
        nodes[id] = {
          ...base,
          type: "image",
          width: comp.width || 480,
          height: comp.height || 320,
          src: comp.props?.src || comp.url || "https://placehold.co/800x600",
        };
      } else {
        nodes[id] = { ...base, type: comp.type || "rect", fill: "#e5e7eb", height: comp.height || 80 };
      }
      childIds.push(id);
    });

    nodes[sectionId] = {
      id: sectionId,
      type: section.type || "frame",
      name: section.name || "Section",
      parent: frameId,
      children: childIds,
      layout,
      constraints: { horizontal: "left", vertical: "top" },
      width: section.width || width - 96,
      height: section.height || 400,
    };
    rootFrame.children.push(sectionId);
  });

  nodes[frameId] = rootFrame;

  return {
    id: makeId(),
    name: blueprint.name || metadata.name || "AI Template",
    description: blueprint.description || metadata.description || "Generated by Dropple AI",
    frame: { width, height, background: "#ffffff" },
    nodes: Object.values(nodes),
  };
}

function convertUniversalBlueprint(bp = {}, metadata = {}) {
  const width = bp.width || metadata.width || 1080;
  const height = bp.height || metadata.height || 1350;
  const rootId = makeId();
  const nodes = {};
  const fonts = bp.fonts || [];
  const primaryFont = fonts[0] || "Inter";
  const animations = (bp.animations || []).map(normalizeAnimation);
  const idMap = {};

  nodes[rootId] = {
    id: rootId,
    type: "frame",
    name: bp.name || metadata.name || "AI Template",
    x: 0,
    y: 0,
    width,
    height,
    children: [],
    layout: { enabled: false },
    constraints: { horizontal: "left", vertical: "top" },
    background: bp.background || "#ffffff",
  };

  (bp.nodes || []).forEach((n, idx) => {
    const id = n.id || makeId();
    idMap[n.id || id] = id;
    if (n.type === "text") {
      nodes[id] = {
        id,
        type: "text",
        text: n.content || n.text || "Text",
        fontSize: n.fontSize || 24,
        fontWeight: n.fontWeight || 600,
        fill: n.color || "#0f172a",
        fontFamily: n.font || primaryFont,
        x: n.x ?? 100,
        y: n.y ?? 100 + idx * 40,
        width: n.width ?? 600,
        height: n.height ?? Math.max(32, (n.fontSize || 16) + 12),
        parent: rootId,
        children: [],
        constraints: { horizontal: "left", vertical: "top" },
      };
    } else if (n.type === "image") {
      nodes[id] = {
        id,
        type: "image",
        src: n.url || n.imageUrl || n.src || placeholderImage(n.imageId || id),
        x: n.x ?? 0,
        y: n.y ?? 0,
        width: n.width ?? width,
        height: n.height ?? Math.round(height * 0.5),
        parent: rootId,
        children: [],
        constraints: { horizontal: "left", vertical: "top" },
      };
    } else if (n.type === "shape") {
      nodes[id] = {
        id,
        type: "frame",
        name: n.shape || "shape",
        x: n.x ?? 80,
        y: n.y ?? 80 + idx * 60,
        width: n.width ?? width - 160,
        height: n.height ?? 240,
        background: n.fill || "#e5e7eb",
        borderRadius: n.radius ?? n.cornerRadius ?? 0,
        parent: rootId,
        children: [],
        layout: { enabled: false },
        constraints: { horizontal: "left", vertical: "top" },
      };
    } else {
      nodes[id] = {
        id,
        type: "frame",
        name: n.type || "frame",
        x: n.x ?? 80,
        y: n.y ?? 80 + idx * 60,
        width: n.width ?? 400,
        height: n.height ?? 240,
        background: n.fill || "#f3f4f6",
        parent: rootId,
        children: [],
        layout: { enabled: false },
        constraints: { horizontal: "left", vertical: "top" },
      };
    }
    nodes[rootId].children.push(id);
  });

  // Attach animations to nodes
  animations.forEach((anim) => {
    const targetId = anim.nodeId && idMap[anim.nodeId] ? idMap[anim.nodeId] : anim.nodeId;
    if (!targetId || !nodes[targetId]) return;
    nodes[targetId].animations = [...(nodes[targetId].animations || []), { ...anim, id: anim.id || makeId() }];
  });

  return {
    id: makeId(),
    name: bp.name || metadata.name || "AI Template",
    description: bp.description || metadata.description || "Generated by Dropple AI",
    frame: { width, height, background: bp.background || "#ffffff" },
    nodes: Object.values(nodes),
    animations,
  };
}

function normalizeAnimation(anim = {}) {
  if (anim.variants) return anim;
  if (anim.states) return { ...anim, variants: anim.states };
  return anim;
}

function placeholderImage(seed = "") {
  const suffix = typeof seed === "string" ? seed.slice(-6) : Math.random().toString(36).slice(2, 8);
  return `https://images.unsplash.com/photo-1522202176988-66273c2fd55f?auto=format&fit=crop&w=1200&q=80&sat=-10&sig=${suffix}`;
}
